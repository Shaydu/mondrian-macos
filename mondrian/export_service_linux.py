#!/usr/bin/env python3
"""
Export Service for Mondrian on Linux
Handles PDF/image export of analysis results with consolidated views
Runs as a lightweight companion service to job_service_v2.3
"""

import os
import sys
import json
import logging
import argparse
import re
import base64
import sqlite3
from io import BytesIO
from pathlib import Path
from datetime import datetime
from typing import Optional
import requests

try:
    from PIL import Image
    HAS_PILLOW = True
except ImportError:
    HAS_PILLOW = False

try:
    from weasyprint import HTML, CSS
    HAS_WEASYPRINT = True
except ImportError:
    HAS_WEASYPRINT = False

from flask import Flask, request, jsonify, Response, send_file
from flask_cors import CORS

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# Service URLs
JOB_SERVICE_URL = "http://127.0.0.1:5005"
AI_ADVISOR_URL = "http://127.0.0.1:5100"

app = Flask(__name__)
CORS(app)


# ==================== CONFIG HELPER FUNCTIONS ====================

def get_config(db_path: str, key: str) -> Optional[str]:
    """Get a configuration value from the database config table"""
    try:
        conn = sqlite3.connect(db_path, timeout=5)
        cursor = conn.cursor()
        cursor.execute("SELECT value FROM config WHERE key = ?", (key,))
        result = cursor.fetchone()
        conn.close()
        if result:
            value = result[0]
            if isinstance(value, bytes):
                value = value.decode('utf-8')
            return value
        return None
    except Exception as e:
        logger.error(f"Error fetching config {key}: {e}")
        return None


def get_disclaimer_text(db_path: str = None) -> str:
    """Get disclaimer text from database config, with fallback to default"""
    if db_path:
        disclaimer = get_config(db_path, "disclaimer")
        if disclaimer:
            return disclaimer
    
    # Fallback to default disclaimer if not in database
    return """AI-Generated Analysis: This report is generated by artificial intelligence and represents a simulated perspective of the named advisor. It is not a professional critique from an actual photographer or art expert.

Creative Guidance Only: These recommendations should be used as creative guidance and inspiration, not as definitive professional advice. Individual artistic interpretation and personal vision may vary.

Not Professional Advice: This analysis is not a substitute for professional photography instruction, mentorship, or critique. For professional assessment, consult with qualified photography educators or critics."""


class ExportService:
    """Manages export operations and HTML consolidation"""
    
    def __init__(self):
        self.job_service_url = JOB_SERVICE_URL
        self.advisor_service_url = AI_ADVISOR_URL
        self.max_image_width = 800  # Max width in pixels
        self.max_image_height = 600  # Max height in pixels
        self.image_quality = 75  # JPEG quality 0-100
        self.max_pdf_size_mb = 2.0  # Maximum PDF size in MB
        self.max_images_in_pdf = 15  # Maximum number of images to include (user photo + case studies)
    
    def compress_base64_image(self, base64_str: str, max_kb: int = 30) -> str:
        """
        Compress a base64-encoded image to reduce file size.
        Targets 30KB per image for total PDF under 1.5MB.
        Returns optimized base64 string.
        """
        if not HAS_PILLOW or not base64_str:
            return base64_str
        
        try:
            # Extract the base64 data (remove data URL prefix if present)
            if ',' in base64_str:
                base64_str = base64_str.split(',')[1]
            
            # Decode base64
            img_data = base64.b64decode(base64_str)
            
            # Check if already small enough
            if len(img_data) / 1024 < max_kb:
                return base64_str
            
            # Load image and resize
            img = Image.open(BytesIO(img_data))
            
            # Convert RGBA to RGB if needed (for JPEG)
            if img.mode == 'RGBA':
                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                rgb_img.paste(img, mask=img.split()[3])
                img = rgb_img
            
            # Resize if too large
            img.thumbnail((self.max_image_width, self.max_image_height), Image.Resampling.LANCZOS)
            
            # Compress and try different quality levels
            quality = self.image_quality
            while quality > 30:
                output = BytesIO()
                img.save(output, format='JPEG', quality=quality, optimize=True)
                size_kb = len(output.getvalue()) / 1024
                
                if size_kb <= max_kb:
                    compressed = base64.b64encode(output.getvalue()).decode('utf-8')
                    logger.info(f"Compressed image: {len(img_data)/1024:.1f}KB → {size_kb:.1f}KB (quality: {quality})")
                    return compressed
                
                quality -= 10
            
            # If still too large, return the last attempt
            output = BytesIO()
            img.save(output, format='JPEG', quality=30, optimize=True)
            return base64.b64encode(output.getvalue()).decode('utf-8')
        
        except Exception as e:
            logger.warning(f"Could not compress image: {e}")
            return base64_str
    
    def compress_html_images(self, html: str) -> str:
        """
        Find all base64 embedded images in HTML and compress them.
        Limits to max_images_in_pdf images and targets max_kb per image.
        Returns HTML with optimized images.
        """
        if not html or not HAS_PILLOW:
            return html
        
        # Pattern to match base64 images in img src attributes
        pattern = r'src="(data:image/[^;]+;base64,[^"]+)"'
        matches = list(re.finditer(pattern, html))
        
        logger.info(f"Found {len(matches)} images in HTML for PDF export")
        
        # If too many images, we'll keep them all but compress more aggressively
        if len(matches) > self.max_images_in_pdf:
            logger.warning(f"PDF has {len(matches)} images, exceeding limit of {self.max_images_in_pdf}. Compressing more aggressively.")
            # Don't remove images - just compress them more
            max_kb_per_image = max(15, int((self.max_pdf_size_mb * 1024 * 0.6) / len(matches)))
        else:
            # Calculate max KB per remaining image
            max_kb_per_image = max(20, int((self.max_pdf_size_mb * 1024 * 0.7) / max(1, len(matches))))
        
        logger.info(f"Target size per image: {max_kb_per_image}KB")
        
        def replace_image(match):
            original = match.group(1)
            try:
                # Extract base64 part
                base64_part = original.split(',')[1]
                compressed = self.compress_base64_image(base64_part, max_kb=max_kb_per_image)
                return f'src="data:image/jpeg;base64,{compressed}"'
            except Exception as e:
                logger.warning(f"Could not compress inline image: {e}")
                return match.group(0)
        
        return re.sub(pattern, replace_image, html)
    
    def get_job_data(self, job_id: str) -> dict:
        """Fetch job data from job service"""
        try:
            response = requests.get(f"{self.job_service_url}/jobs/{job_id}", timeout=10)
            if response.status_code == 200:
                return response.json()
            logger.error(f"Failed to fetch job {job_id}: {response.status_code}")
            return None
        except Exception as e:
            logger.error(f"Error fetching job data: {e}")
            return None
    
    def get_advisor_info(self, advisor_id: str) -> dict:
        """Fetch advisor information"""
        try:
            response = requests.get(f"{self.job_service_url}/advisors/{advisor_id}", timeout=10)
            if response.status_code == 200:
                data = response.json()
                # Extract advisor data from wrapper
                return data.get('advisor', {}) if 'advisor' in data else data
            logger.warning(f"Failed to fetch advisor {advisor_id}: {response.status_code}")
            return {}
        except Exception as e:
            logger.warning(f"Error fetching advisor info: {e}")
            return {}
    
    def extract_html_body(self, html: str) -> str:
        """Extract body content from HTML string"""
        if not html:
            return ""
        
        try:
            # Find the body tag content
            start = html.find("<body>") + 6
            end = html.find("</body>")
            if start > 5 and end > start:
                return html[start:end]
        except Exception as e:
            logger.error(f"Error extracting HTML body: {e}")
        
        return html
    
    def get_image_as_base64(self, filename: str) -> Optional[str]:
        """Load an image file and convert to base64 for embedding"""
        try:
            # Try to find the file
            if os.path.exists(filename):
                filepath = filename
            elif os.path.exists(os.path.join('uploads', filename)):
                filepath = os.path.join('uploads', filename)
            elif os.path.exists(os.path.join('/home/doo/dev/mondrian-macos', filename)):
                filepath = os.path.join('/home/doo/dev/mondrian-macos', filename)
            else:
                logger.warning(f"Image file not found: {filename}")
                return None
            
            with open(filepath, 'rb') as f:
                img_data = f.read()
            
            # Compress if needed
            if HAS_PILLOW:
                img = Image.open(filepath)
                
                # Convert RGBA to RGB if needed
                if img.mode == 'RGBA':
                    rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                    rgb_img.paste(img, mask=img.split()[3])
                    img = rgb_img
                
                # Resize to reasonable dimensions for top of report
                max_width = 600
                max_height = 400
                img.thumbnail((max_width, max_height), Image.Resampling.LANCZOS)
                
                # Save as JPEG with compression
                output = BytesIO()
                img.save(output, format='JPEG', quality=85, optimize=True)
                img_data = output.getvalue()
                
                logger.info(f"Loaded and compressed user image: {len(img_data)/1024:.1f}KB")
            
            return base64.b64encode(img_data).decode('utf-8')
        
        except Exception as e:
            logger.error(f"Error loading image {filename}: {e}")
            return None
    
    def generate_pdf_from_html(self, html: str, job_id: str) -> Optional[bytes]:
        """
        Convert HTML to PDF with CSS rendering.
        Uses WeasyPrint if available, otherwise falls back to basic compression.
        Returns PDF bytes or None if conversion fails.
        """
        try:
            if HAS_WEASYPRINT:
                logger.info(f"Generating PDF using WeasyPrint for job {job_id}")
                pdf_bytes = HTML(string=html).write_pdf()
                pdf_size_mb = len(pdf_bytes) / (1024 * 1024)
                logger.info(f"Generated PDF size: {pdf_size_mb:.2f}MB for job {job_id}")
                
                # If PDF is still too large, try to compress more aggressively
                if pdf_size_mb > self.max_pdf_size_mb:
                    logger.warning(f"PDF too large ({pdf_size_mb:.2f}MB), attempting to compress images further...")
                    # Reduce image count and try again
                    html = re.sub(
                        r'src="(data:image/[^;]+;base64,[^"]+)"',
                        lambda m: '' if len(re.findall(r'src="(data:image', html)) > 5 else m.group(0),
                        html,
                        count=max(0, len(re.findall(r'src="(data:image', html)) - 5)
                    )
                    pdf_bytes = HTML(string=html).write_pdf()
                
                return pdf_bytes
            else:
                logger.warning("WeasyPrint not available for PDF generation")
                return None
        except Exception as e:
            logger.error(f"Error generating PDF: {e}")
            return None
    
    def generate_consolidated_export_html(self, job_id: str, db_path: str = None) -> str:
        """
        Generate consolidated export HTML with:
        - Summary at top (Top 3 Recommendations)
        - Detailed analysis in middle
        - Advisor info at bottom
        - Metadata footer with timestamp and advisor
        - Disclaimer (pulled from database config)
        
        Optimized for PDF/image export with clean, simple styling and compressed images.
        """
        
        # Get disclaimer text from database (with fallback to default)
        disclaimer_text = get_disclaimer_text(db_path)
        
        job = self.get_job_data(job_id)
        if not job:
            return self._error_html(f"Job {job_id} not found")
        
        # Extract data
        status = job.get('status', 'unknown')
        if status != 'completed':
            return self._error_html(f"Job not completed (status: {status})")
        
        advisor_id = job.get('advisor', 'unknown')
        advisor_info = self.get_advisor_info(advisor_id)
        
        summary_html = job.get('summary_html', '')
        analysis_html = job.get('analysis_html', '')
        
        # Extract bodies from HTML responses
        summary_body = self.extract_html_body(summary_html)
        analysis_body = self.extract_html_body(analysis_html)
        
        # Get user's uploaded image
        filename = job.get('filename', '')
        user_image_base64 = self.get_image_as_base64(filename) if filename else None
        
        # Get timestamp
        created_at = job.get('created_at', datetime.now().isoformat())
        
        # Build consolidated HTML
        html = f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mondrian Analysis Export - {job_id[:8]}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.5;
            color: #1a1a1a;
            background: #ffffff;
            padding: 30px 20px;
            max-width: 850px;
            margin: 0 auto;
        }}
        
        /* Page breaks for PDF - avoid breaks in the middle of cards */
        .summary-container,
        .feedback-card,
        .case-study-box,
        .advisor-section {{
            page-break-inside: avoid;
        }}
        
        /* Header */
        .export-header {{
            border-bottom: 2px solid #333;
            padding-bottom: 15px;
            margin-bottom: 25px;
        }}
        
        .export-header h1 {{
            font-size: 26px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 5px;
        }}
        
        .export-header p {{
            color: #666;
            font-size: 13px;
        }}
        
        /* Section headings */
        .section-title {{
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 25px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
        }}
        
        .section-title:first-of-type {{
            margin-top: 0;
        }}
        
        /* Summary section */
        .summary-container {{
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }}
        
        .summary-container h1,
        .summary-header {{
            display: none;
        }}
        
        .recommendations-list {{
            display: flex;
            flex-direction: column;
            gap: 10px;
        }}
        
        .recommendation-item {{
            background: #ffffff;
            padding: 10px;
            border-left: 3px solid #0066cc;
            border-radius: 2px;
        }}
        
        .rec-number {{
            display: inline-block;
            width: 22px;
            height: 22px;
            background: #0066cc;
            color: #ffffff;
            border-radius: 50%;
            text-align: center;
            line-height: 22px;
            font-weight: 600;
            font-size: 11px;
            margin-right: 6px;
        }}
        
        .rec-text {{
            display: inline;
            color: #1a1a1a;
            font-size: 13px;
        }}
        
        .disclaimer {{
            background: #fff3cd;
            border-left: 3px solid #ff9500;
            padding: 10px;
            margin-top: 12px;
            border-radius: 2px;
            font-size: 11px;
            color: #333;
        }}
        
        /* Analysis section */
        .analysis {{
            background: #ffffff;
            padding: 0;
            margin: 15px 0;
        }}
        
        .analysis h2 {{
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 15px 0 10px 0;
        }}
        
        .analysis p {{
            color: #333;
            font-size: 13px;
            margin-bottom: 10px;
            line-height: 1.5;
        }}
        
        .feedback-card {{
            background: #f5f5f5;
            margin: 12px 0;
            padding: 12px;
            border-left: 3px solid #0066cc;
            border-radius: 2px;
        }}
        
        .feedback-card h3 {{
            color: #1a1a1a;
            font-size: 14px;
            margin: 0 0 6px 0;
            font-weight: 600;
        }}
        
        .feedback-comment {{
            background: #ffffff;
            padding: 8px;
            margin: 8px 0;
            border-left: 2px solid #ddd;
            border-radius: 2px;
        }}
        
        .feedback-comment p {{
            margin: 0;
            color: #333;
            font-size: 12px;
        }}
        
        .feedback-recommendation {{
            background: #e8f4f8;
            padding: 8px;
            margin: 8px 0;
            border-left: 2px solid #0066cc;
            border-radius: 2px;
        }}
        
        .feedback-recommendation p {{
            margin: 0;
            color: #333;
            font-size: 12px;
        }}
        
        /* Images - optimized for PDF */
        img {{
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
            border-radius: 2px;
        }}
        
        /* User's photo section */
        .user-photo-section {{
            background: #f5f5f5;
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 25px;
            text-align: center;
        }}
        
        .user-photo-section img {{
            max-width: 600px;
            max-height: 400px;
            margin: 0 auto 12px auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }}
        
        .user-photo-caption {{
            color: #666;
            font-size: 12px;
            font-style: italic;
            margin-top: 8px;
        }}
        
        .case-study-box {{
            background: #ffffff;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 2px;
        }}
        
        .case-study-title {{
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 6px;
            font-size: 12px;
        }}
        
        .case-study-box img {{
            margin: 6px 0;
        }}
        
        .case-study-metadata {{
            font-size: 11px;
            color: #666;
            margin-top: 6px;
        }}
        
        /* Advisor section */
        .advisor-section {{
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin-top: 25px;
        }}
        
        .advisor-profile {{
            background: #ffffff;
            padding: 12px;
            border-radius: 2px;
        }}
        
        .advisor-headshot {{
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 50%;
            float: right;
            margin-left: 15px;
            margin-bottom: 10px;
        }}
        
        .advisor-profile h1 {{
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0 0 3px 0;
        }}
        
        .advisor-years {{
            color: #666;
            font-size: 12px;
            margin-bottom: 8px;
        }}
        
        .advisor-bio {{
            color: #333;
            font-size: 12px;
            line-height: 1.5;
            margin-bottom: 8px;
        }}
        
        .link-button {{
            display: inline-block;
            color: #0066cc;
            text-decoration: none;
            font-size: 12px;
            margin-right: 10px;
            margin-top: 6px;
        }}
        
        /* Footer */
        .export-footer {{
            border-top: 1px solid #ddd;
            margin-top: 30px;
            padding-top: 15px;
            font-size: 11px;
            color: #999;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }}
        
        .footer-item {{
            display: flex;
            flex-direction: column;
        }}
        
        .footer-label {{
            font-weight: 600;
            color: #666;
            margin-bottom: 2px;
        }}
        
        .footer-value {{
            color: #999;
        }}
        
        /* Disclaimer section */
        .disclaimer-section {{
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-left: 3px solid #ff9500;
            padding: 12px;
            margin-top: 30px;
            border-radius: 2px;
            font-size: 10px;
            color: #555;
            line-height: 1.4;
        }}
        
        .disclaimer-section h3 {{
            font-size: 11px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0 0 6px 0;
        }}
        
        .disclaimer-section p {{
            margin: 0 0 4px 0;
        }}
        
        .disclaimer-section ul {{
            margin: 4px 0;
            padding-left: 15px;
        }}
        
        .disclaimer-section li {{
            margin: 2px 0;
        }}
        
        /* Mobile adjustments */
        @media (max-width: 600px) {{
            body {{
                padding: 15px 10px;
            }}
            .export-header h1 {{
                font-size: 20px;
            }}
            .section-title {{
                font-size: 16px;
            }}
        }}
    </style>
</head>
<body>

<!-- HEADER -->
<div class="export-header">
    <h1>Photography Analysis Report</h1>
    <p>Detailed feedback and recommendations</p>
</div>

<!-- USER'S PHOTO -->
{f'''<div class="user-photo-section">
    <img src="data:image/jpeg;base64,{user_image_base64}" alt="Your photograph" />
    <p class="user-photo-caption">Your photograph</p>
</div>''' if user_image_base64 else ''}

<!-- SUMMARY SECTION -->
<div class="section-title">Summary - Top Recommendations</div>
<div class="summary-container">
    {summary_body}
</div>

<!-- DETAILED ANALYSIS SECTION -->
<div class="section-title">Detailed Feedback</div>
<div class="analysis-container">
    {analysis_body}
</div>

<!-- ADVISOR SECTION -->
<div class="section-title">About Your Advisor</div>
<div class="advisor-section">
    {self._generate_advisor_footer_html(advisor_info, advisor_id)}
</div>

<!-- METADATA FOOTER -->
<div class="export-footer">
    <div class="footer-item">
        <span class="footer-label">Report ID</span>
        <span class="footer-value">{job_id[:8]}...</span>
    </div>
    <div class="footer-item">
        <span class="footer-label">Advisor</span>
        <span class="footer-value">{advisor_info.get('name', advisor_id)}</span>
    </div>
    <div class="footer-item">
        <span class="footer-label">Generated</span>
        <span class="footer-value">{datetime.fromisoformat(created_at).strftime('%Y-%m-%d %H:%M')}</span>
    </div>
    <div class="footer-item">
        <span class="footer-label">Service</span>
        <span class="footer-value">Mondrian AI</span>
    </div>
</div>

<!-- DISCLAIMER -->
<div class="disclaimer-section">
    <h3>⚠ Important Disclaimer</h3>
    {disclaimer_text}
</div>

</body>
</html>'''
        
        # Compress images in the HTML
        html = self.compress_html_images(html)
        
        return html
    
    def _generate_advisor_footer_html(self, advisor_info: dict, advisor_id: str) -> str:
        """Generate advisor info footer HTML"""
        
        if not advisor_info:
            return f'''<div class="advisor-profile">
    <h1>{advisor_id.title()}</h1>
    <p class="advisor-bio">Advisor information not available.</p>
</div>'''
        
        name = advisor_info.get('name', advisor_id.title())
        years = advisor_info.get('years', '')
        bio = advisor_info.get('bio', 'No biography available.')
        
        # Get links from learn_more nested structure
        learn_more = advisor_info.get('learn_more', {})
        wikipedia_url = learn_more.get('wikipedia', {}).get('url', '')
        commons_url = learn_more.get('gallery', {}).get('url', '')
        
        # Get advisor image
        image_url = advisor_info.get('image_url', '')
        image_html = ''
        if image_url:
            try:
                response = requests.get(image_url, timeout=10)
                if response.status_code == 200:
                    import base64
                    b64_image = base64.b64encode(response.content).decode('utf-8')
                    mime_type = response.headers.get('content-type', 'image/jpeg')
                    image_html = f'<img src="data:{mime_type};base64,{b64_image}" alt="{name}" class="advisor-headshot" />'
            except Exception as e:
                logger.warning(f"Failed to fetch advisor image: {e}")
        
        years_html = f'<div class="advisor-years">{years}</div>' if years else ''
        
        links_html = ''
        if wikipedia_url:
            links_html += f'<a href="{wikipedia_url}" class="link-button">Wikipedia</a>'
        if commons_url:
            links_html += f'<a href="{commons_url}" class="link-button">Gallery</a>'
        
        return f'''<div class="advisor-profile">
    {image_html}
    <h1>{name}</h1>
    {years_html}
    <p class="advisor-bio">{bio}</p>
    {links_html}
</div>'''
    
    def _error_html(self, message: str) -> str:
        """Generate error HTML"""
        return f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Export Error</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 40px;
            color: #d32f2f;
            background: #fafafa;
        }}
        .error-container {{
            max-width: 600px;
            margin: 0 auto;
            background: #ffffff;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #ffebee;
        }}
        h1 {{ color: #c62828; margin-bottom: 10px; }}
        p {{ color: #d32f2f; }}
    </style>
</head>
<body>
    <div class="error-container">
        <h1>Export Error</h1>
        <p>{message}</p>
    </div>
</body>
</html>'''


# Initialize service
export_service = ExportService()


# ==================== API ENDPOINTS ====================

@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({
        "status": "UP",
        "service": "export",
        "timestamp": datetime.now().isoformat(),
        "job_service": JOB_SERVICE_URL,
        "advisor_service": AI_ADVISOR_URL
    }), 200


@app.route('/export/<job_id>', methods=['GET'])
def export_consolidated(job_id: str):
    """
    Export consolidated analysis as HTML or PDF.
    
    Combines:
    - Summary (top 3 recommendations)
    - Detailed analysis (full feedback)
    - Advisor information (bottom)
    - Metadata footer
    
    Query params:
    - format: 'html' (default), 'pdf', 'json' (metadata only)
    
    PDF export includes:
    - Full CSS rendering
    - Compressed images (max 1.5MB total)
    - Professional formatting
    """
    
    try:
        format_type = request.args.get('format', 'html').lower()
        
        if format_type == 'json':
            # Return metadata as JSON
            job = export_service.get_job_data(job_id)
            if not job:
                return jsonify({"error": "Job not found"}), 404
            
            advisor_info = export_service.get_advisor_info(job.get('advisor', ''))
            
            return jsonify({
                "job_id": job_id,
                "status": job.get('status'),
                "advisor": job.get('advisor'),
                "advisor_name": advisor_info.get('name', job.get('advisor')),
                "created_at": job.get('created_at'),
                "mode": job.get('mode'),
                "export_ready": job.get('status') == 'completed',
                "export_formats": ["html", "pdf" if HAS_WEASYPRINT else "html", "json"]
            }), 200
        
        elif format_type == 'pdf':
            # Generate and return PDF
            if not HAS_WEASYPRINT:
                return jsonify({
                    "error": "PDF generation not available. Install weasyprint: pip install weasyprint",
                    "fallback": "Use format=html and print to PDF from browser"
                }), 503
            
            html = export_service.generate_consolidated_export_html(job_id)
            pdf_bytes = export_service.generate_pdf_from_html(html, job_id)
            
            if not pdf_bytes:
                return jsonify({"error": "Failed to generate PDF"}), 500
            
            # Create response with cache-busting headers and filename
            import hashlib
            timestamp = int(datetime.now().timestamp())
            content_hash = hashlib.md5(f"{job_id}{timestamp}".encode()).hexdigest()[:6]
            
            response = Response(
                pdf_bytes,
                mimetype='application/pdf',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate, max-age=0',
                    'Pragma': 'no-cache',
                    'Expires': '0',
                    'Content-Disposition': f'attachment; filename="analysis-{job_id[:8]}-{content_hash}.pdf"',
                    'Last-Modified': datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT'),
                    'ETag': f'"{job_id}-{timestamp}"'
                }
            )
            return response
        
        else:
            # Return consolidated HTML (default)
            html = export_service.generate_consolidated_export_html(job_id)
            
            return Response(
                html,
                mimetype='text/html; charset=utf-8',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate, max-age=0',
                    'Pragma': 'no-cache',
                    'Expires': '0',
                    'Last-Modified': datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT'),
                    'ETag': f'"{job_id}-{int(datetime.now().timestamp())}"'
                }
            )
    
    except Exception as e:
        logger.error(f"Export error for job {job_id}: {e}")
        return jsonify({"error": str(e)}), 500


@app.route('/export/<job_id>/metadata', methods=['GET'])
def export_metadata(job_id: str):
    """Get export metadata for a job"""
    try:
        job = export_service.get_job_data(job_id)
        if not job:
            return jsonify({"error": "Job not found"}), 404
        
        advisor_info = export_service.get_advisor_info(job.get('advisor', ''))
        
        return jsonify({
            "job_id": job_id,
            "status": job.get('status'),
            "advisor": job.get('advisor'),
            "advisor_name": advisor_info.get('name', job.get('advisor')),
            "created_at": job.get('created_at'),
            "mode": job.get('mode'),
            "is_completed": job.get('status') == 'completed',
            "export_formats": ["html", "json"]
        }), 200
    
    except Exception as e:
        logger.error(f"Metadata error for job {job_id}: {e}")
        return jsonify({"error": str(e)}), 500


# ==================== MAIN ====================

def main():
    parser = argparse.ArgumentParser(
        description='Export Service for Mondrian - Handles PDF/image export of analysis results'
    )
    parser.add_argument('--port', type=int, default=5007, help='Port to run service on (default: 5007)')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to (default: 0.0.0.0)')
    parser.add_argument('--job-service-url', default='http://127.0.0.1:5005', help='URL of job service')
    parser.add_argument('--advisor-service-url', default='http://127.0.0.1:5100', help='URL of AI advisor service')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    
    args = parser.parse_args()
    
    # Update service URLs if provided
    if args.job_service_url != 'http://127.0.0.1:5005':
        global JOB_SERVICE_URL
        JOB_SERVICE_URL = args.job_service_url
        export_service.job_service_url = JOB_SERVICE_URL
    
    if args.advisor_service_url != 'http://127.0.0.1:5100':
        global AI_ADVISOR_URL
        AI_ADVISOR_URL = args.advisor_service_url
        export_service.advisor_service_url = AI_ADVISOR_URL
    
    logger.info(f"Export Service starting on {args.host}:{args.port}")
    logger.info(f"Job Service URL: {export_service.job_service_url}")
    logger.info(f"Advisor Service URL: {export_service.advisor_service_url}")
    logger.info(f"PDF Support: {'✓ Enabled (WeasyPrint)' if HAS_WEASYPRINT else '✗ Disabled (install: pip install weasyprint)'}")
    logger.info(f"Image Compression: {'✓ Enabled (Pillow)' if HAS_PILLOW else '✗ Disabled (install: pip install Pillow)'}")
    logger.info(f"Max PDF Size: {export_service.max_pdf_size_mb}MB | Max Images: {export_service.max_images_in_pdf}")
    
    app.run(host=args.host, port=args.port, debug=args.debug)


if __name__ == '__main__':
    main()
